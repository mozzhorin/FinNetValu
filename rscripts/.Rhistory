rep(c(0.5,1,1.5,2,2.5,3,3.5,4,4.5,5,6,8,10,12,14), each=50)
X = rep(c(0.5,1,1.5,2,2.5,3,3.5,4,4.5,5,6,8,10,12,14), each=50);
floor(30*5.0)
library(tidyverse)
library(igraph)
library(stringr)
library(ggthemes)
draw_network <- function (N, M, num_edges) {
r.graph <- sample_bipartite(N,M,type = "gnm", m=num_edges, directed = FALSE)
as_incidence_matrix(r.graph)
}
calc_AM <- function (A, total_ext_assets) {
total_ext_assets / (rowSums(A) + .Machine$double.eps) * A ## TODO: Fix me
}
bank_states <- function (solvent, total_ext_assets, total_liq_assets, deposits) {
list(solvent = solvent,
total_ext_assets = total_ext_assets,
total_liq_assets = total_liq_assets,
deposits = deposits,
capital = total_ext_assets + total_liq_assets - deposits)
}
asset_states <- function (market_depth, prices) {
list(market_depth = market_depth,
prices = prices)
}
failing_banks <- function (AM, bank_states, asset_states) {
ext_asset_value <- AM %*% asset_states$prices
failing <- bank_states$solvent & (ext_asset_value + bank_states$total_liq_assets - bank_states$deposits < 0)
## Return failing banks
failing
}
sell_assets <- function (AM, failing_banks, asset_states, params) {
asset_amounts <- colSums(AM) + .Machine$double.eps
frac_liquidated <- colSums(AM[failing_banks, , drop=FALSE])/asset_amounts
## Return new asset prices
asset_states$prices * exp(- params$Alpha * frac_liquidated) ## TODO: include market depth
}
propagate_asset_shock <- function (AM, bank_states, asset_states, params) {
failed <- failing_banks(AM, bank_states, asset_states)
if (any(failed)) {
asset_prices <- sell_assets(AM, failed, asset_states, params)
propagate_asset_shock(AM,
modifyList(bank_states, list(solvent=bank_states$solvent & !failed)),
modifyList(asset_states, list(prices=asset_prices)),
params)
} else {
list(banks = bank_states, assets = asset_states)
}
}
propagate_bank_shock <- function (AM, bank_states, asset_states, params) {
failed <- !bank_states$solvent
asset_prices <- sell_assets(AM, failed, asset_states, params)
propagate_asset_shock(AM,
modifyList(bank_states, list(solvent=bank_states$solvent & !failed)),
modifyList(asset_states, list(prices=asset_prices)),
params)
}
test_this <- function (A) {
Total.asset <- matrix(data = 1, nrow = N, ncol = 1)
Total.ext.asset <- Ext.asset.frac * Total.asset
Total.liquid.asset <- Liquid.asset.frac * Total.asset
Capital <- Capital.frac * Total.asset
Deposits <- Total.ext.asset + Total.liquid.asset - Capital
AM <- calc_AM(A, c(Total.ext.asset))
Total.liquid.asset[rowSums(A) == 0] <- 1
bs <- bank_states(rep(TRUE, N),
Total.ext.asset,
Total.liquid.asset,
Deposits)
tada <- matrix(FALSE, nrow=M, ncol=N)
for (i in 1:M) {
## Shock asset i
as <- asset_states(NULL, rep(1, M))
as$prices[i] <- Reduction.factor*as$prices[i]
foo <- propagate_asset_shock(AM, bs, as, list(alpha=Alpha))
tada[i,] <- !foo$banks$solvent
}
tada
}
global_params <-
list(## Bank parameters
Liquid.asset.frac = 0.2,
Ext.asset.frac = 0.8,
Capital.frac = 0.1,
## Asset shock parameters
Reduction.factor = 0.3,
Alpha = 1.0536,
## Bailout parameters
No.of.padded.banks = 5,
New.capital.frac = 1)
init_states <- function (A, params) {
N <- nrow(A)
M <- ncol(A)
Total.asset <- rep(1, N) ## c(rep(5, 20), rep(1, N-20))
Total.ext.asset <- params$Ext.asset.frac * Total.asset
Total.liquid.asset <- params$Liquid.asset.frac * Total.asset
Capital <- params$Capital.frac * Total.asset
Deposits <- Total.ext.asset + Total.liquid.asset - Capital
## Fix banks with no connections to external assets
Total.liquid.asset[rowSums(A) == 0] <- 1
bs <- bank_states(rep(TRUE, N),
Total.ext.asset,
Total.liquid.asset,
Deposits)
as <- asset_states(rep(1, M), rep(1, M))
list(banks = bs, assets = as)
}
shock_assets <- function (asset_states, shocked_assets, params) {
asset_states$prices[shocked_assets] <- params$Reduction.factor*asset_states$prices[shocked_assets]
asset_states
}
shock_banks <- function (bank_states, shocked_banks) {
bank_states$solvent[shocked_banks] <- FALSE
bank_states
}
run_asset_shocks <- function (graphml_files, scenario, params) {
results <- data_frame(graph = character(0),
scenario = character(0),
shocked_asset = integer(0),
failed_banks = list())
for (gf in graphml_files) {
print(paste("Processing", gf))
g <- read_graph(gf, "graphml")
A <- as_incidence_matrix(g)
states <- init_states(A, params)
AM <- calc_AM(A, states$banks$total_ext_assets)
if (scenario == "none") {
## Do nothing
} else if (scenario == "rnd") {
## Randomly bailout banks
random_padding <- sample(1:nrow(A),params$No.of.padded.banks,replace=F)
total <- states$banks$total_ext_assets + states$banks$total_liq_assets
states$banks$deposits[random_padding] <-
total[random_padding] - params$New.capital.frac*total[random_padding]
} else if (scenario == "cont") {
Omega <- AM %*% diag(1/states$assets$market_depth) %*% t(AM)
lead.eig <- abs( eigen(Omega)$vectors[,1] )
cont_padding <- order(lead.eig, decreasing=TRUE)[1:params$No.of.padded.banks]
total <- states$banks$total_ext_assets + states$banks$total_liq_assets
states$banks$deposits[cont_padding] <-
total[cont_padding] - params$New.capital.frac*total[cont_padding]
} else if (scenario == "my") {
Omega <- AM %*% diag(1/states$assets$market_depth) %*% t(AM)
Omega.rel <- diag(params$Capital.frac, nrow=nrow(Omega)) %*% Omega
cent <- rowSums(Omega.rel) * colSums(Omega.rel)
my_padding <- order(cent, decreasing=TRUE)[1:params$No.of.padded.banks]
total <- states$banks$total_ext_assets + states$banks$total_liq_assets
states$banks$deposits[my_padding] <-
total[my_padding] - params$New.capital.frac*total[my_padding]
} else if (scenario == "sasi") {
## Compute bank centralities
proj <- bipartite_projection(g)
banks.one.mode <- proj[[1]]
assets.one.mode <- proj[[2]]
N <- nrow(A)
M <- ncol(A)
Bank.centrality <- rep(0, N)
for(i in 1:(M-1)) {
for(j in (i+1):M) {
if(sum(AM[,i]*AM[,j])==0) next
Bank.centrality <- Bank.centrality + AM[,i]*AM[,j]/sum(AM[,i]*AM[,j])*
edge_betweenness(assets.one.mode,e=E(assets.one.mode)[i%--%j],
directed=FALSE,weights=NULL)
}
}
## Bank.centrality <- Bank.centrality/(.Machine[[1]] + (rowSums(A) * (rowSums(A) - 1))/2)
padding <- order(Bank.centrality, decreasing=TRUE)[1:params$No.of.padded.banks]
total <- states$banks$total_ext_assets + states$banks$total_liq_assets
states$banks$deposits[padding] <-
total[padding] - params$New.capital.frac*total[padding]
} else {
stop("Unknown scenario ", scenario)
}
for (idx in 1:ncol(A)) {
## Shock asset i
as <- shock_assets(states$assets, idx, params)
sim <- propagate_asset_shock(AM, states$banks, as, params)
## Store simulation results
results <- bind_rows(results,
list(graph=gf, scenario=scenario, shocked_asset=idx,
failed_banks=list(which(!sim$banks$solvent))))
}
}
results
}
create_and_save_graphs <- function (N, M, bank_degrees) {
sapply(1:length(bank_degrees),
function (id) {
bd <- bank_degrees[id]
g_name <- paste0("Banks", N, "Assets", M, "bank_degree", bd, "ID", id, ".graphml")
E <- floor(N*bd)
g <- sample_bipartite(N,M,type = "gnm", m=E, directed = FALSE)
write_graph(g, g_name, "graphml")
})
"Done"
}
create_and_save_graphs(25, 30, rep(c(0.5,1,1.5,2,2.5,3,3.5,4,4.5,5,6,8,10,12,14), each=50))
## Model follows Cont (eq. (21) and (22))
## Changes:
## * Separate bank balance sheet size and portfolio holdings (as in Greenwood)
## * Flexible parametrization to allow for non-linear market impact and leverage targeting rules
library(tidyverse)
library(readxl)
library(lubridate)
state <- function (capital, exposures) {
## Exposures corresponds to Pi matrix of Cont
num_banks = nrow(exposures)
num_assets = ncol(exposures)
bank_sizes = rowSums(exposures)
portfolios = exposures / bank_sizes
list(capital = capital,
Pi = exposures)
## bank_balance_sheet = bank_sizes,
## portfolios = portfolios)
}
params <- function (market_impact, leverage_strategy, alpha) {
list(market_impact = market_impact,
leverage_strategy = leverage_strategy,
alpha = alpha)
}
sim_step <- function (state, loss, params) {
Pi <- state$Pi ## diag(state$bank_balance_sheet) %*% state$portfolios
Gamma <- params$leverage_strategy(state, loss)
## Compute new exposure values (13)
Psi <- params$market_impact(c(Gamma %*% Pi), colSums(Pi))
Pi_next <- diag(1 - Gamma) %*% Pi %*% diag(1 - Psi)
## Compute losses
## M <- (1 - Gamma) * rowSums(Pi - Pi_next)
## R <- Gamma * rowSums(Pi - (params$alpha*Pi_next + (1-params$alpha)*Pi))
M <- (1 - Gamma) * (Pi %*% Psi)
R <- (1 - (1 - params$alpha) * Gamma) * (Pi %*% Psi)
L <- c(M + R)
## Update state
state_new = modifyList(state,
list(Pi = Pi_next,
capital = pmax(state$capital - L, 0)))
list(state = state_new, loss = L)
}
simulate <- function (state, loss, params, iter=100) {
banks <- rownames(state$Pi)
if (is.null(banks))
banks <- 1:nrow(state$Pi)
df <- data_frame(bank = banks, loss = loss, step = 0,
capital = state$capital, assets = rowSums(state$Pi))
sl <- list(state = state, loss = loss)
for (i in 1:iter) {
sl_next <- sim_step(sl$state, sl$loss, params)
if (all(sl_next$loss == 0))
break
df <- bind_rows(df, data_frame(bank = banks, loss = sl_next$loss, step = i,
capital = sl_next$state$capital, assets = rowSums(sl_next$state$Pi)))
sl <- sl_next
}
df
}
market_impact_linear <- function (D) {
function (q, S) {
min(1, q / D)
}
}
market_impact_exp <- function (D) {
function (q, S) {
1 - exp(- q / D)
}
}
market_impact_frac <- function (q, S) {
1 - exp(- 1.0536 * q / (S + .Machine$double.eps))
}
market_impact_cont <- function (D, B, S0) {
delta <- (1 - B / S0) * D
function (q, S) {
(1 - B / S) * (1 - exp(- q / delta))
}
}
leverage_cont <- function (lambda_max, lambda_b) {
function (state, loss) {
ass <- rowSums(state$Pi)
cap <- state$capital
lambda <- ass / (cap + .Machine$double.eps)
Gamma <- ((lambda_b - 1) * loss - cap * (lambda_b - lambda)) / (ass + .Machine$double.eps)
pmin(Gamma * (lambda > lambda_max), 1)
}
}
leverage_target <- function (leverage_target) {
function (state, loss) {
}
}
leverage_default <- function (state, loss) {
as.numeric(!(state$capital > 0))
}
shock_assets <- function (state, assets, reduction_factor) {
Pi_shock <- state$Pi
Pi_shock[,assets] <- reduction_factor * Pi_shock[,assets]
loss <- rowSums(state$Pi) - rowSums(Pi_shock)
cap <- pmax(state$capital - loss, 0)
list(state = modifyList(state, list(capital = cap, Pi = Pi_shock)),
loss = loss)
}
Pi = cbind(c(90, 70))
cap = c(4, 4.5)
rownames(Pi) <- c("Bank A","Bank B")
#colnames(cap) <- c("Bank A","Bank B")
colnames(Pi) <- c("Asset 1")
D = 0.4 * (50/0.02) * sqrt(20)
B = 0.5
S0 = 1
alpha = 1.
lambda_max = 33.3
lambda_b = 0.95 * lambda_max
banks <- rownames(Pi)
N <- nrow(Pi)
M <- ncol(Pi)
state_cont <- state(cap, Pi)
params_default <- params(market_impact_cont(D, B, S0), leverage_cont(lambda_max, lambda_b), alpha)
sl <- shock_assets(state_cont, colnames(Pi), c(0.9778, 1.))
Pi <- sl$state$Pi ## diag(state$bank_balance_sheet) %*% state$portfolios
Gamma <- params_default$leverage_strategy(sl$state, sl$loss)
Psi <- params_default$market_impact(c(Gamma %*% Pi), colSums(Pi))
Pi_next <- diag(1 - Gamma) %*% Pi %*% (1 - Psi)
