ass <- rowSums(state$Pi)
cap <- state$capital
lambda <- ass / (cap + .Machine$double.eps)
Gamma <- ((lambda_b - 1) * loss - cap * (lambda_b - lambda)) / (ass + .Machine$double.eps)
pmin(Gamma * (lambda > lambda_max), 1)
}
}
leverage_target <- function (leverage_target) {
function (state, loss) {
}
}
leverage_default <- function (state, loss) {
as.numeric(!(state$capital > 0))
}
#source("EBA_Cont.R")
#--------------------------#
# two bank example from Shaanning 2017 (thesis)
Pi = cbind(c(90, 70))
cap = cbind(c(4, 4.5))
#rownames(Pi) <- c("Bank A","Bank B")
#rownames(cap) <- c("Bank A","Bank B")
#colnames(Pi) <- c("Asset 1")
D = 0.4 * (50/0.02) * sqrt(20)
B = 0.5
S0 = 1
alpha = 0.5
lambda_max = 33
lambda_b = 0.95 * lambda_max
N <- nrow(Pi)
M <- ncol(Pi)
state_cont <- state(cap, Pi)
params_default <- params(market_impact_cont(D, B, S0), leverage_cont(lambda_max, lambda_b), alpha)
loss <- c(0.05, 0)
sim_step(state_cont, loss, params_default)
View(Pi)
dim(Pi)
Pi = cbind(c(90, 70))
cap = c(4, 4.5)
#rownames(Pi) <- c("Bank A","Bank B")
#rownames(cap) <- c("Bank A","Bank B")
#colnames(Pi) <- c("Asset 1")
D = 0.4 * (50/0.02) * sqrt(20)
B = 0.5
S0 = 1
alpha = 0.5
lambda_max = 33
lambda_b = 0.95 * lambda_max
N <- nrow(Pi)
M <- ncol(Pi)
state_cont <- state(cap, Pi)
state_cont
params_default <- params(market_impact_cont(D, B, S0), leverage_cont(lambda_max, lambda_b), alpha)
loss <- c(0.05, 0)
sim_step(state_cont, loss, params_default)
loss <- c(0.15, 0)
sim_step(state_cont, loss, params_default)
loss =
lapply(banks, function (b) {
sl <- shock_banks(state_cont, b)
simulate(sl$state, sl$loss, params_default) %>%
## Compute total loss
group_by(bank) %>%
arrange(desc(step)) %>%
summarize(loss = sum(loss), capital = first(capital))
})
shock_banks <- function (state, banks) {
N <- nrow(state$Pi)
loss <- rep(0, N)
names(loss) <- rownames(state$Pi)
loss[banks] <- state$capital[banks]
cap <- state$capital
cap[banks] <- 0
list(state = modifyList(state, list(capital = cap)),
loss = loss)
}
shock_assets <- function (state, assets, reduction_factor) {
Pi_shock <- state$Pi
Pi_shock[,assets] <- reduction_factor * Pi_shock[,assets]
loss <- rowSums(state$Pi) - rowSums(Pi_shock)
cap <- pmax(state$capital - loss, 0)
list(state = modifyList(state, list(capital = cap, Pi = Pi_shock)),
loss = loss)
}
sl <- shock_banks(state_cont, b)
sl <- shock_banks(state_cont, banks)
shock_banks_WS <- function (state) {
N <- nrow(state$Pi)
loss <- rep(0, N)
names(loss) <- rownames(state$Pi)
loss <- state$capital
cap <- state$capital
cap <- 0
list(state = modifyList(state, list(capital = cap)),
loss = loss)
}
sl <- shock_banks_WS(state_cont)
Gamma <- params$leverage_strategy(state_cont, loss)
Gamma <- params_default$leverage_strategy(state_cont, loss)
loss <- c(0.4, 0)
Gamma <- params_default$leverage_strategy(state_cont, loss)
cap = c(2, 4.5)
state_cont <- state(cap, Pi)
loss <- c(0.2, 0)
Gamma <- params_default$leverage_strategy(state_cont, loss)
Gamma
rownames(Pi) <- c("Bank A","Bank B")
library(tidyverse)
library(readxl)
library(lubridate)
state <- function (capital, exposures) {
## Exposures corresponds to Pi matrix of Cont
num_banks = nrow(exposures)
num_assets = ncol(exposures)
bank_sizes = rowSums(exposures)
portfolios = exposures / bank_sizes
list(capital = capital,
Pi = exposures)
## bank_balance_sheet = bank_sizes,
## portfolios = portfolios)
}
params <- function (market_impact, leverage_strategy, alpha) {
list(market_impact = market_impact,
leverage_strategy = leverage_strategy,
alpha = alpha)
}
sim_step <- function (state, loss, params) {
Pi <- state$Pi ## diag(state$bank_balance_sheet) %*% state$portfolios
Gamma <- params$leverage_strategy(state, loss)
## Compute new exposure values (13)
Psi <- params$market_impact(c(Gamma %*% Pi), colSums(Pi))
Pi_next <- diag(1 - Gamma) %*% Pi %*% diag(1 - Psi)
## Compute losses
## M <- (1 - Gamma) * rowSums(Pi - Pi_next)
## R <- Gamma * rowSums(Pi - (params$alpha*Pi_next + (1-params$alpha)*Pi))
M <- (1 - Gamma) * (Pi %*% Psi)
R <- (1 - (1 - params$alpha) * Gamma) * (Pi %*% Psi)
L <- c(M + R)
## Update state
state_new = modifyList(state,
list(Pi = Pi_next,
capital = pmax(state$capital - L, 0)))
list(state = state_new, loss = L)
}
simulate <- function (state, loss, params, iter=100) {
banks <- rownames(state$Pi)
if (is.null(banks))
banks <- 1:nrow(state$Pi)
df <- data_frame(bank = banks, loss = loss, step = 0,
capital = state$capital, assets = rowSums(state$Pi))
sl <- list(state = state, loss = loss)
for (i in 1:iter) {
sl_next <- sim_step(sl$state, sl$loss, params)
if (all(sl_next$loss == 0))
break
df <- bind_rows(df, data_frame(bank = banks, loss = sl_next$loss, step = i,
capital = sl_next$state$capital, assets = rowSums(sl_next$state$Pi)))
sl <- sl_next
}
df
}
market_impact_linear <- function (D) {
function (q, S) {
min(1, q / D)
}
}
market_impact_exp <- function (D) {
function (q, S) {
1 - exp(- q / D)
}
}
market_impact_frac <- function (q, S) {
1 - exp(- 1.0536 * q / (S + .Machine$double.eps))
}
market_impact_cont <- function (D, B, S0) {
delta <- (1 - B / S0) * D
function (q, S) {
(1 - B / S) * (1 - exp(- q / delta))
}
}
leverage_cont <- function (lambda_max, lambda_b) {
function (state, loss) {
ass <- rowSums(state$Pi)
cap <- state$capital
lambda <- ass / (cap + .Machine$double.eps)
Gamma <- ((lambda_b - 1) * loss - cap * (lambda_b - lambda)) / (ass + .Machine$double.eps)
pmin(Gamma * (lambda > lambda_max), 1)
}
}
leverage_target <- function (leverage_target) {
function (state, loss) {
}
}
leverage_default <- function (state, loss) {
as.numeric(!(state$capital > 0))
}
#source("EBA_Cont.R")
#--------------------------#
# two bank example from Shaanning 2017 (thesis)
Pi = cbind(c(90, 70))
cap = c(2, 4.5)
rownames(Pi) <- c("Bank A","Bank B")
View(Pi)
cap
Pi
colnames(cap) <- c("Bank A","Bank B")
banks <- rownames(cont.Pi)
banks <- rownames(Pi)
D = 0.4 * (50/0.02) * sqrt(20)
B = 0.5
S0 = 1
alpha = 0.5
lambda_max = 33
lambda_b = 0.95 * lambda_max
N <- nrow(Pi)
M <- ncol(Pi)
state_cont <- state(cap, Pi)
state_cont$capital[banks]
colnames(Pi) <- c("Asset 1")
sim_df <- data_frame(shocked_asset = colnames(Pi),
loss =
lapply(shocked_asset, function (a) {
sl <- shock_assets(state_cont, a, 0.9)
simulate(sl$state, sl$loss, params_default)
})) %>%
unnest()
shock_assets <- function (state, assets, reduction_factor) {
Pi_shock <- state$Pi
Pi_shock[,assets] <- reduction_factor * Pi_shock[,assets]
loss <- rowSums(state$Pi) - rowSums(Pi_shock)
cap <- pmax(state$capital - loss, 0)
list(state = modifyList(state, list(capital = cap, Pi = Pi_shock)),
loss = loss)
}
sim_df <- data_frame(shocked_asset = colnames(Pi),
loss =
lapply(shocked_asset, function (a) {
sl <- shock_assets(state_cont, a, 0.9)
simulate(sl$state, sl$loss, params_default)
})) %>%
unnest()
Pi[,colnames(Pi)]
sim_df <- data_frame(shocked_asset = colnames(Pi),
loss =
lapply(shocked_asset, function (a) {
sl <- shock_assets(state_cont, a, 0.9)
simulate(sl$state, sl$loss, params_default)
})) %>%
unnest()
sim_df <- data_frame(shocked_asset = colnames(Pi),
loss =
lapply(shocked_asset, function (a) {
sl <- shock_assets(state_cont, a, 0.9)
simulate(sl$state, sl$loss, params_default)
})) %>%
unnest()
sim_df <- data_frame(shocked_asset = colnames(Pi),
loss =
lapply(shocked_asset, function (a) {
sl <- shock_assets(state_cont, a, 0.9)
simulate(sl$state, sl$loss, params_default)
})) %>%
unnest()
Pi_shock <- state_cont$Pi
assets = colnames(Pi)
Pi_shock[,assets] <- 0.9 * Pi_shock[,assets]
Pi_shock[,assets]
Pi_shock[,colnames(Pi)]
Pi[colnames(Pi)]
Pi[,colnames(Pi)]
View(Pi)
Pi
state_cont.Pi
state_cont$Pi
state_cont <- state(cap, Pi)
sim_df <- data_frame(shocked_asset = colnames(Pi),
loss =
lapply(shocked_asset, function (a) {
sl <- shock_assets(state_cont, a, 0.9)
simulate(sl$state, sl$loss, params_default)
})) %>%
unnest()
params_default <- params(market_impact_cont(D, B, S0), leverage_cont(lambda_max, lambda_b), alpha)
loss <- c(0.2, 0)
sim_df <- data_frame(shocked_asset = colnames(Pi),
loss =
lapply(shocked_asset, function (a) {
sl <- shock_assets(state_cont, a, 0.9)
simulate(sl$state, sl$loss, params_default)
})) %>%
unnest()
sim_df <- data_frame(shocked_bank = banks,
loss =
lapply(banks, function (b) {
sl <- shock_banks(state_cont, b)
simulate(sl$state, sl$loss, params_default) %>%
## Compute total loss
group_by(bank) %>%
arrange(desc(step)) %>%
summarize(loss = sum(loss), capital = first(capital))
})) %>%
unnest()
shock_banks <- function (state, banks) {
N <- nrow(state$Pi)
loss <- rep(0, N)
names(loss) <- rownames(state$Pi)
loss[banks] <- state$capital[banks]
cap <- state$capital
cap[banks] <- 0
list(state = modifyList(state, list(capital = cap)),
loss = loss)
}
sim_df <- data_frame(shocked_bank = banks,
loss =
lapply(banks, function (b) {
sl <- shock_banks(state_cont, b)
simulate(sl$state, sl$loss, params_default) %>%
## Compute total loss
group_by(bank) %>%
arrange(desc(step)) %>%
summarize(loss = sum(loss), capital = first(capital))
})) %>%
unnest()
sim_df <- data_frame(shocked_bank = banks,
loss =
lapply(banks, function (b) {
sl <- shock_banks(state_cont, b)
simulate(sl$state, sl$loss, params_default) %>%
## Compute total loss
group_by(bank) %>%
arrange(desc(step)) %>%
summarize(loss = sum(loss), capital = first(capital))
})) %>%
unnest()
sl <- shock_banks(state_cont, banks)
simulate(sl$state, sl$loss, params_default)
cap = c(4, 4.5)
state_cont <- state(cap, Pi)
params_default <- params(market_impact_cont(D, B, S0), leverage_cont(lambda_max, lambda_b), alpha)
loss <- c(0.2, 0)
sl <- shock_banks(state_cont, banks)
simulate(sl$state, sl$loss, params_default)
sl <- shock_assets(state_cont, colnames(Pi), 0.9)
simulate(sl$state, sl$loss, params_default)
sl <- shock_assets(state_cont, colnames(Pi), 0.05)
simulate(sl$state, sl$loss, params_default)
state_cont <- state(cap, Pi)
sl <- shock_assets(state_cont, colnames(Pi), 0.05)
library(tidyverse)
library(readxl)
library(lubridate)
state <- function (capital, exposures) {
## Exposures corresponds to Pi matrix of Cont
num_banks = nrow(exposures)
num_assets = ncol(exposures)
bank_sizes = rowSums(exposures)
portfolios = exposures / bank_sizes
list(capital = capital,
Pi = exposures)
## bank_balance_sheet = bank_sizes,
## portfolios = portfolios)
}
params <- function (market_impact, leverage_strategy, alpha) {
list(market_impact = market_impact,
leverage_strategy = leverage_strategy,
alpha = alpha)
}
sim_step <- function (state, loss, params) {
Pi <- state$Pi ## diag(state$bank_balance_sheet) %*% state$portfolios
Gamma <- params$leverage_strategy(state, loss)
## Compute new exposure values (13)
Psi <- params$market_impact(c(Gamma %*% Pi), colSums(Pi))
Pi_next <- diag(1 - Gamma) %*% Pi %*% diag(1 - Psi)
## Compute losses
## M <- (1 - Gamma) * rowSums(Pi - Pi_next)
## R <- Gamma * rowSums(Pi - (params$alpha*Pi_next + (1-params$alpha)*Pi))
M <- (1 - Gamma) * (Pi %*% Psi)
R <- (1 - (1 - params$alpha) * Gamma) * (Pi %*% Psi)
L <- c(M + R)
## Update state
state_new = modifyList(state,
list(Pi = Pi_next,
capital = pmax(state$capital - L, 0)))
list(state = state_new, loss = L)
}
simulate <- function (state, loss, params, iter=100) {
banks <- rownames(state$Pi)
if (is.null(banks))
banks <- 1:nrow(state$Pi)
df <- data_frame(bank = banks, loss = loss, step = 0,
capital = state$capital, assets = rowSums(state$Pi))
sl <- list(state = state, loss = loss)
for (i in 1:iter) {
sl_next <- sim_step(sl$state, sl$loss, params)
if (all(sl_next$loss == 0))
break
df <- bind_rows(df, data_frame(bank = banks, loss = sl_next$loss, step = i,
capital = sl_next$state$capital, assets = rowSums(sl_next$state$Pi)))
sl <- sl_next
}
df
}
market_impact_linear <- function (D) {
function (q, S) {
min(1, q / D)
}
}
market_impact_exp <- function (D) {
function (q, S) {
1 - exp(- q / D)
}
}
market_impact_frac <- function (q, S) {
1 - exp(- 1.0536 * q / (S + .Machine$double.eps))
}
market_impact_cont <- function (D, B, S0) {
delta <- (1 - B / S0) * D
function (q, S) {
(1 - B / S) * (1 - exp(- q / delta))
}
}
leverage_cont <- function (lambda_max, lambda_b) {
function (state, loss) {
ass <- rowSums(state$Pi)
cap <- state$capital
lambda <- ass / (cap + .Machine$double.eps)
Gamma <- ((lambda_b - 1) * loss - cap * (lambda_b - lambda)) / (ass + .Machine$double.eps)
pmin(Gamma * (lambda > lambda_max), 1)
}
}
leverage_target <- function (leverage_target) {
function (state, loss) {
}
}
leverage_default <- function (state, loss) {
as.numeric(!(state$capital > 0))
}
Pi = cbind(c(90, 70))
cap = c(4, 4.5)
rownames(Pi) <- c("Bank A","Bank B")
#colnames(cap) <- c("Bank A","Bank B")
colnames(Pi) <- c("Asset 1")
D = 0.4 * (50/0.02) * sqrt(20)
B = 0.5
S0 = 1
alpha = 0.5
lambda_max = 33
lambda_b = 0.95 * lambda_max
banks <- rownames(Pi)
N <- nrow(Pi)
M <- ncol(Pi)
state_cont <- state(cap, Pi)
params_default <- params(market_impact_cont(D, B, S0), leverage_cont(lambda_max, lambda_b), alpha)
sl <- shock_assets(state_cont, colnames(Pi), 0.05)
shock_banks <- function (state, banks) {
N <- nrow(state$Pi)
loss <- rep(0, N)
names(loss) <- rownames(state$Pi)
loss[banks] <- state$capital[banks]
cap <- state$capital
cap[banks] <- 0
list(state = modifyList(state, list(capital = cap)),
loss = loss)
}
shock_assets <- function (state, assets, reduction_factor) {
Pi_shock <- state$Pi
Pi_shock[,assets] <- reduction_factor * Pi_shock[,assets]
loss <- rowSums(state$Pi) - rowSums(Pi_shock)
cap <- pmax(state$capital - loss, 0)
list(state = modifyList(state, list(capital = cap, Pi = Pi_shock)),
loss = loss)
}
sl <- shock_assets(state_cont, colnames(Pi), 0.05)
simulate(sl$state, sl$loss, params_default)
loss <- c(0.2, 0)
sim_step(state_cont, loss, params_default)
sim_df <- data_frame(shocked_asset = colnames(Pi),
loss =
lapply(shocked_asset, function (a) {
sl <- shock_assets(state_cont, a, 0.9)
simulate(sl$state, sl$loss, params_default)
})) %>%
unnest()
sim_df <- data_frame(shocked_asset = colnames(Pi),
loss =
lapply(shocked_asset, function (a) {
sl <- shock_assets(state_cont, a, 0.05)
simulate(sl$state, sl$loss, params_default)
})) %>%
unnest()
Gamma <- params_default$leverage_strategy(state_cont, loss)
Psi <- params_default$market_impact(c(Gamma %*% Pi), colSums(Pi))
Pi %*% diag(1 - Psi)
diag(1 - Gamma) %*% Pi
diag(1 - Gamma) %*% Pi %*% diag(1 - Psi)
Pi_next <- diag(1 - Gamma) %*% Pi %*% diag(1 - Psi)
sim_df <- data_frame(shocked_asset = colnames(Pi),
loss =
lapply(shocked_asset, function (a) {
sl <- shock_assets(state_cont, a, 0.05)
simulate(sl$state, sl$loss, params_default)
})) %>%
unnest()
shocked_asset = colnames(Pi)
loss =
lapply(shocked_asset, function (a) {
sl <- shock_assets(state_cont, a, 0.05)
simulate(sl$state, sl$loss, params_default)
})
sl <- shock_assets(state_cont, shocked_asset, 0.05)
sl <- shock_assets(state_cont, shocked_asset, 0.9)
sl <- shock_assets(state_cont, shocked_asset, 0.8)
simulate(sl$state, sl$loss, params_default)
